—-

## Cobra Command

Additional commands can be defined and typically are each given their own file inside of the cmd/ directory.

If you wanted to create a version command you would create cmd/version.go and populate it with the following:

<details><summary>show</summary>
<p>

```
package cmd

import (
  "fmt"

  "github.com/spf13/cobra"
)

func init() {
  rootCmd.AddCommand(versionCmd)
}

var versionCmd = &cobra.Command{
  Use:   "version",
  Short: "Print the version number of Hugo",
  Long:  `All software has versions. This is Hugo's`,
  Run: func(cmd *cobra.Command, args []string) {
    fmt.Println("Hugo Static Site Generator v0.9 -- HEAD")
  },
}

```golang

</p>
</details>

—-

## Cobra- Persistent Flags

A flag can be 'persistent' meaning that this flag will be available to the command it's assigned to as well as every command under that command. For global flags, assign a flag as a persistent flag on the root.

<details><summary>show</summary>
<p>

```golang 

rootCmd.PersistentFlags().BoolVarP(&Verbose, "verbose", "v", false, "verbose output")

```

</p>
</details>

—-

## Cobra- Local Flags

A flag can also be assigned locally which will only apply to that specific command.

<details><summary>show</summary>
<p>

```
rootCmd.Flags().StringVarP(&Source, "source", "s", "", "Source directory to read from")

```

</p>
</details>

—-

## Cobra- Local Flag on Parent Commands

By default Cobra only parses local flags on the target command, any local flags on parent commands are ignored. By enabling Command.TraverseChildren Cobra will parse local flags on each command before executing the target command.

<details><summary>show</summary>
<p>

```
command := cobra.Command{
  Use: "print [OPTIONS] [COMMANDS]",
  TraverseChildren: true,
}

```

</p>
</details>

—-

## Cobra- Bind Flags with Config

You can also bind your flags with viper:

<details><summary>show</summary>
<p>

```
var author string

func init() {
  rootCmd.PersistentFlags().StringVar(&author, "author", "YOUR NAME", "Author name for copyright attribution")
  viper.BindPFlag("author", rootCmd.PersistentFlags().Lookup("author"))
}

```

</p>
</details>

—-

## Cobra- Required flags

Flags are optional by default. If instead you wish your command to report an error when a flag has not been set, mark it as required:

<details><summary>show</summary>
<p>

```
rootCmd.Flags().StringVarP(&Region, "region", "r", "", "AWS region (required)")
rootCmd.MarkFlagRequired("region")

```

</p>
</details>

—-

## Cobra- Positional and Custom Arguments

Validation of positional arguments can be specified using the Args field of Command.



<details><summary>show</summary>
<p>

```
The following validators are built in:

* NoArgs - the command will report an error if there are any positional args.
* ArbitraryArgs - the command will accept any args.
* OnlyValidArgs - the command will report an error if there are any positional args that are not in the ValidArgs field of Command.
* MinimumNArgs(int) - the command will report an error if there are not at least N positional args.
* MaximumNArgs(int) - the command will report an error if there are more than N positional args.
* ExactArgs(int) - the command will report an error if there are not exactly N positional args.
* RangeArgs(min, max) - the command will report an error if the number of args is not between the minimum and maximum number of expected args.

```

</p>
</details>

—-

## Cobra- Setting the custom validator:

<details><summary>show</summary>
<p>

```golang
var cmd = &cobra.Command{
  Short: "hello",
  Args: func(cmd *cobra.Command, args []string) error {
    if len(args) < 1 {
      return errors.New("requires at least one arg")
    }
    if myapp.IsValidColor(args[0]) {
      return nil
    }
    return fmt.Errorf("invalid color specified: %s", args[0])
  },
  Run: func(cmd *cobra.Command, args []string) {
    fmt.Println("Hello, World!")
  },
}

```

</p>
</details>

—-

## Cobra- Example

In the example below, we have defined three commands. Two are at the top level and one (cmdTimes) is a child of one of the top commands. In this case the root is not executable meaning that a subcommand is required. This is accomplished by not providing a 'Run' for the 'rootCmd'.

<details><summary>show</summary>
<p>

```
package main

import (
  "fmt"
  "strings"

  "github.com/spf13/cobra"
)

func main() {
  var echoTimes int

  var cmdPrint = &cobra.Command{
    Use:   "print [string to print]",
    Short: "Print anything to the screen",
    Long: `print is for printing anything back to the screen.
For many years people have printed back to the screen.`,
    Args: cobra.MinimumNArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
      fmt.Println("Print: " + strings.Join(args, " "))
    },
  }

  var cmdEcho = &cobra.Command{
    Use:   "echo [string to echo]",
    Short: "Echo anything to the screen",
    Long: `echo is for echoing anything back.
Echo works a lot like print, except it has a child command.`,
    Args: cobra.MinimumNArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
      fmt.Println("Print: " + strings.Join(args, " "))
    },
  }

  var cmdTimes = &cobra.Command{
    Use:   "times [# times] [string to echo]",
    Short: "Echo anything to the screen more times",
    Long: `echo things multiple times back to the user by providing
a count and a string.`,
    Args: cobra.MinimumNArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
      for i := 0; i < echoTimes; i++ {
        fmt.Println("Echo: " + strings.Join(args, " "))
      }
    },
  }

  cmdTimes.Flags().IntVarP(&echoTimes, "times", "t", 1, "times to echo the input")

  var rootCmd = &cobra.Command{Use: "app"}
  rootCmd.AddCommand(cmdPrint, cmdEcho)
  cmdEcho.AddCommand(cmdTimes)
  rootCmd.Execute()
}

```

</p>
</details>

—-

## What is Viper?

Viper is a complete configuration solution for Go applications including 12-Factor apps. It is designed to work within an application, and can handle all types of configuration needs and formats. It supports:


<details><summary>show</summary>
<p>

```
* setting defaults
* reading from JSON, TOML, YAML, HCL, and Java properties config files
* live watching and re-reading of config files (optional)
* reading from environment variables
* reading from remote config systems (etcd or Consul), and watching changes
* reading from command line flags
* reading from buffer
* setting explicit values

Viper can be thought of as a registry for all of your applications configuration needs.

```

</p>
</details>

—-

## Why Viper?

When building a modern application, you don’t want to worry about configuration file formats; you want to focus on building awesome software. Viper is here to help with that.

Viper does the following for you:


<details><summary>show</summary>
<p>

```
* Find, load, and unmarshal a configuration file in JSON, TOML, YAML, HCL, or Java properties formats.
* Provide a mechanism to set default values for your different configuration options.
* Provide a mechanism to set override values for options specified through command line flags.
* Provide an alias system to easily rename parameters without breaking existing code.
* Make it easy to tell the difference between when a user has provided a command line or config file which is the same as the default.


```

</p>
</details>

—-

## Viper uses the following precedence order. Each item takes precedence over the item below it:


<details><summary>show</summary>
<p>

```
* explicit call to Set
* flag
* env
* config
* key/value store
* default

Viper configuration keys are case insensitive.


```

</p>
</details>

—-

## Establishing Defaults

A good configuration system will support default values. A default value is not required for a key, but it’s useful in the event that a key hasn’t been set via config file, environment variable, remote configuration or flag.

Examples:

<details><summary>show</summary>
<p>

```
viper.SetDefault("ContentDir", "content")
viper.SetDefault("LayoutDir", "layouts")
viper.SetDefault("Taxonomies", map[string]string{"tag": "tags", "category": "categories"})

```

</p>
</details>

—-

## Watching and re-reading config files

Viper supports the ability to have your application live read a config file while running.

Make sure you add all of the configPaths prior to calling WatchConfig()

<details><summary>show</summary>
<p>

```
viper.WatchConfig()
viper.OnConfigChange(func(e fsnotify.Event) {
	fmt.Println("Config file changed:", e.Name)
})

```

</p>
</details>

—-

## Env example

<details><summary>show</summary>
<p>

```
SetEnvPrefix("spf") // will be uppercased automatically
BindEnv("id")

os.Setenv("SPF_ID", "13") // typically done outside of the app

id := Get("id") // 13

```

</p>
</details>

—-

## Viper- Individual flag binding

For individual flags, the BindPFlag() method provides this functionality.

Example:

<details><summary>show</summary>
<p>

```
serverCmd.Flags().Int("port", 1138, "Port to run Application server on")
viper.BindPFlag("port", serverCmd.Flags().Lookup("port"))


```

</p>
</details>

—-

## Viper- Binding to existing flags

You can also bind an existing set of pflags (pflag.FlagSet):

Example:


<details><summary>show</summary>
<p>

```
pflag.Int("flagname", 1234, "help message for flagname")

pflag.Parse()
viper.BindPFlags(pflag.CommandLine)

i := viper.GetInt("flagname") // retrieve values from viper instead of pflag


```

</p>
</details>

—-

## Remote Key/Value Store Support

To enable remote support in Viper, do a blank import of the viper/remote package:

import _ "github.com/spf13/viper/remote"

<details><summary>show</summary>
<p>

```
You can use remote configuration in conjunction with local configuration, or independently of it.

crypt has a command-line helper that you can use to put configurations in your K/V store. crypt defaults to etcd on http://127.0.0.1:4001.

```

</p>
</details>

—-

## Title

<details><summary>show</summary>
<p>

```


```

</p>
</details>

—-

## Title

<details><summary>show</summary>
<p>

```
go get github.com/xordataexchange/crypt/bin/crypt
crypt set -plaintext /config/hugo.json /Users/hugo/settings/config.json

# Confirm that your value was set:

crypt get -plaintext /config/hugo.json

```

</p>
</details>

—-

## Remote Key/Value Store Example - Unencrypted

Etcd

<details><summary>show</summary>
<p>

```
viper.AddRemoteProvider("etcd", "http://127.0.0.1:4001","/config/hugo.json")
viper.SetConfigType("json") // because there is no file extension in a stream of bytes, supported extensions are "json", "toml", "yaml", "yml", "properties", "props", "prop"
err := viper.ReadRemoteConfig()

```

</p>
</details>

—-

## Remote Key/Value Store Example - Encrypted

<details><summary>show</summary>
<p>

```
viper.AddSecureRemoteProvider("etcd","http://127.0.0.1:4001","/config/hugo.json","/etc/secrets/mykeyring.gpg")
viper.SetConfigType("json") // because there is no file extension in a stream of bytes,  supported extensions are "json", "toml", "yaml", "yml", "properties", "props", "prop"
err := viper.ReadRemoteConfig()

```

</p>
</details>

—-

## Watching Changes in etcd - Unencrypted

<details><summary>show</summary>
<p>

```
// alternatively, you can create a new viper instance.
var runtime_viper = viper.New()

runtime_viper.AddRemoteProvider("etcd", "http://127.0.0.1:4001", "/config/hugo.yml")
runtime_viper.SetConfigType("yaml") // because there is no file extension in a stream of bytes, supported extensions are "json", "toml", "yaml", "yml", "properties", "props", "prop"

// read from remote config the first time.
err := runtime_viper.ReadRemoteConfig()

// unmarshal config
runtime_viper.Unmarshal(&runtime_conf)

// open a goroutine to watch remote changes forever
go func(){
	for {
	    time.Sleep(time.Second * 5) // delay after each request

	    // currently, only tested with etcd support
	    err := runtime_viper.WatchRemoteConfig()
	    if err != nil {
	        log.Errorf("unable to read remote config: %v", err)
	        continue
	    }

	    // unmarshal new config into our runtime config struct. you can also use channel
	    // to implement a signal to notify the system of the changes
	    runtime_viper.Unmarshal(&runtime_conf)
	}
}()

```

</p>
</details>

—-

## Getting Values From Viper

In Viper, there are a few ways to get a value depending on the value’s type. The following functions and methods exist:

<details><summary>show</summary>
<p>


* Get(key string) : interface{}
* GetBool(key string) : bool
* GetFloat64(key string) : float64
* GetInt(key string) : int
* GetString(key string) : string
* GetStringMap(key string) : map[string]interface{}
* GetStringMapString(key string) : map[string]string
* GetStringSlice(key string) : []string
* GetTime(key string) : time.Time
* GetDuration(key string) : time.Duration
IsSet(key string) : bool
AllSettings() : map[string]interface{}



</p>
</details>

—-

## Accessing nested keys

The accessor methods also accept formatted paths to deeply nested keys. For example, if the following JSON file is loaded:



<details><summary>show</summary>
<p>


```
{
    "host": {
        "address": "localhost",
        "port": 5799
    },
    "datastore": {
        "metric": {
            "host": "127.0.0.1",
            "port": 3099
        },
        "warehouse": {
            "host": "198.0.0.1",
            "port": 2112
        }
    }
}



```

Viper can access a nested field by passing a . delimited path of keys:

GetString("datastore.metric.host") // (returns "127.0.0.1")

</p>
</details>


